// Copyright 1998-2017 Epic Games, Inc. All Rights Reserved.
/*===========================================================================
	Generated code exported from UnrealHeaderTool.
	DO NOT modify this manually! Edit the corresponding .h files instead!
===========================================================================*/

#include "GeneratedCppIncludes.h"
#include "Public/VRGripInterface.h"
PRAGMA_DISABLE_OPTIMIZATION
#ifdef _MSC_VER
#pragma warning (push)
#pragma warning (disable : 4883)
#endif
PRAGMA_DISABLE_DEPRECATION_WARNINGS
void EmptyLinkFunctionForGeneratedCodeVRGripInterface() {}
// Cross Module References
	VREXPANSIONPLUGIN_API UFunction* Z_Construct_UFunction_UVRGripInterface_AdvancedPhysicsSettings();
	VREXPANSIONPLUGIN_API UClass* Z_Construct_UClass_UVRGripInterface();
	VREXPANSIONPLUGIN_API UScriptStruct* Z_Construct_UScriptStruct_FBPAdvGripPhysicsSettings();
	VREXPANSIONPLUGIN_API UFunction* Z_Construct_UFunction_UVRGripInterface_ClosestPrimarySlotInRange();
	VREXPANSIONPLUGIN_API UClass* Z_Construct_UClass_UGripMotionControllerComponent_NoRegister();
	COREUOBJECT_API UScriptStruct* Z_Construct_UScriptStruct_FTransform();
	COREUOBJECT_API UScriptStruct* Z_Construct_UScriptStruct_FVector();
	VREXPANSIONPLUGIN_API UFunction* Z_Construct_UFunction_UVRGripInterface_ClosestSecondarySlotInRange();
	VREXPANSIONPLUGIN_API UFunction* Z_Construct_UFunction_UVRGripInterface_DenyGripping();
	VREXPANSIONPLUGIN_API UFunction* Z_Construct_UFunction_UVRGripInterface_FreeGripType();
	VREXPANSIONPLUGIN_API UEnum* Z_Construct_UEnum_VRExpansionPlugin_EGripCollisionType();
	VREXPANSIONPLUGIN_API UFunction* Z_Construct_UFunction_UVRGripInterface_GetInteractionSettings();
	VREXPANSIONPLUGIN_API UScriptStruct* Z_Construct_UScriptStruct_FBPInteractionSettings();
	VREXPANSIONPLUGIN_API UFunction* Z_Construct_UFunction_UVRGripInterface_GripBreakDistance();
	VREXPANSIONPLUGIN_API UFunction* Z_Construct_UFunction_UVRGripInterface_GripDamping();
	VREXPANSIONPLUGIN_API UFunction* Z_Construct_UFunction_UVRGripInterface_GripLateUpdateSetting();
	VREXPANSIONPLUGIN_API UEnum* Z_Construct_UEnum_VRExpansionPlugin_EGripLateUpdateSettings();
	VREXPANSIONPLUGIN_API UFunction* Z_Construct_UFunction_UVRGripInterface_GripMovementReplicationType();
	VREXPANSIONPLUGIN_API UEnum* Z_Construct_UEnum_VRExpansionPlugin_EGripMovementReplicationSettings();
	VREXPANSIONPLUGIN_API UFunction* Z_Construct_UFunction_UVRGripInterface_GripStiffness();
	VREXPANSIONPLUGIN_API UFunction* Z_Construct_UFunction_UVRGripInterface_IsHeld();
	VREXPANSIONPLUGIN_API UFunction* Z_Construct_UFunction_UVRGripInterface_IsInteractible();
	VREXPANSIONPLUGIN_API UFunction* Z_Construct_UFunction_UVRGripInterface_OnChildGrip();
	VREXPANSIONPLUGIN_API UScriptStruct* Z_Construct_UScriptStruct_FBPActorGripInformation();
	VREXPANSIONPLUGIN_API UFunction* Z_Construct_UFunction_UVRGripInterface_OnChildGripRelease();
	VREXPANSIONPLUGIN_API UFunction* Z_Construct_UFunction_UVRGripInterface_OnEndSecondaryUsed();
	VREXPANSIONPLUGIN_API UFunction* Z_Construct_UFunction_UVRGripInterface_OnEndUsed();
	VREXPANSIONPLUGIN_API UFunction* Z_Construct_UFunction_UVRGripInterface_OnGrip();
	VREXPANSIONPLUGIN_API UFunction* Z_Construct_UFunction_UVRGripInterface_OnGripRelease();
	VREXPANSIONPLUGIN_API UFunction* Z_Construct_UFunction_UVRGripInterface_OnSecondaryGrip();
	ENGINE_API UClass* Z_Construct_UClass_USceneComponent_NoRegister();
	VREXPANSIONPLUGIN_API UFunction* Z_Construct_UFunction_UVRGripInterface_OnSecondaryGripRelease();
	VREXPANSIONPLUGIN_API UFunction* Z_Construct_UFunction_UVRGripInterface_OnSecondaryUsed();
	VREXPANSIONPLUGIN_API UFunction* Z_Construct_UFunction_UVRGripInterface_OnUsed();
	VREXPANSIONPLUGIN_API UFunction* Z_Construct_UFunction_UVRGripInterface_SecondaryGripType();
	VREXPANSIONPLUGIN_API UEnum* Z_Construct_UEnum_VRExpansionPlugin_ESecondaryGripType();
	VREXPANSIONPLUGIN_API UFunction* Z_Construct_UFunction_UVRGripInterface_SetHeld();
	VREXPANSIONPLUGIN_API UFunction* Z_Construct_UFunction_UVRGripInterface_SimulateOnDrop();
	VREXPANSIONPLUGIN_API UFunction* Z_Construct_UFunction_UVRGripInterface_SlotGripType();
	VREXPANSIONPLUGIN_API UFunction* Z_Construct_UFunction_UVRGripInterface_TeleportBehavior();
	VREXPANSIONPLUGIN_API UEnum* Z_Construct_UEnum_VRExpansionPlugin_EGripInterfaceTeleportBehavior();
	VREXPANSIONPLUGIN_API UFunction* Z_Construct_UFunction_UVRGripInterface_TickGrip();
	VREXPANSIONPLUGIN_API UClass* Z_Construct_UClass_UVRGripInterface_NoRegister();
	COREUOBJECT_API UClass* Z_Construct_UClass_UInterface();
	UPackage* Z_Construct_UPackage__Script_VRExpansionPlugin();
// End Cross Module References
	FBPAdvGripPhysicsSettings IVRGripInterface::AdvancedPhysicsSettings()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_AdvancedPhysicsSettings instead.");
		VRGripInterface_eventAdvancedPhysicsSettings_Parms Parms;
		return Parms.ReturnValue;
	}
	void IVRGripInterface::ClosestPrimarySlotInRange(FVector WorldLocation, bool& bHadSlotInRange, FTransform& SlotWorldTransform, UGripMotionControllerComponent* CallingController, FName OverridePrefix)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_ClosestPrimarySlotInRange instead.");
	}
	void IVRGripInterface::ClosestSecondarySlotInRange(FVector WorldLocation, bool& bHadSlotInRange, FTransform& SlotWorldTransform, UGripMotionControllerComponent* CallingController, FName OverridePrefix)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_ClosestSecondarySlotInRange instead.");
	}
	bool IVRGripInterface::DenyGripping()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_DenyGripping instead.");
		VRGripInterface_eventDenyGripping_Parms Parms;
		return Parms.ReturnValue;
	}
	EGripCollisionType IVRGripInterface::FreeGripType()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_FreeGripType instead.");
		VRGripInterface_eventFreeGripType_Parms Parms;
		return Parms.ReturnValue;
	}
	FBPInteractionSettings IVRGripInterface::GetInteractionSettings()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_GetInteractionSettings instead.");
		VRGripInterface_eventGetInteractionSettings_Parms Parms;
		return Parms.ReturnValue;
	}
	float IVRGripInterface::GripBreakDistance()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_GripBreakDistance instead.");
		VRGripInterface_eventGripBreakDistance_Parms Parms;
		return Parms.ReturnValue;
	}
	float IVRGripInterface::GripDamping()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_GripDamping instead.");
		VRGripInterface_eventGripDamping_Parms Parms;
		return Parms.ReturnValue;
	}
	EGripLateUpdateSettings IVRGripInterface::GripLateUpdateSetting()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_GripLateUpdateSetting instead.");
		VRGripInterface_eventGripLateUpdateSetting_Parms Parms;
		return Parms.ReturnValue;
	}
	EGripMovementReplicationSettings IVRGripInterface::GripMovementReplicationType()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_GripMovementReplicationType instead.");
		VRGripInterface_eventGripMovementReplicationType_Parms Parms;
		return Parms.ReturnValue;
	}
	float IVRGripInterface::GripStiffness()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_GripStiffness instead.");
		VRGripInterface_eventGripStiffness_Parms Parms;
		return Parms.ReturnValue;
	}
	void IVRGripInterface::IsHeld(UGripMotionControllerComponent*& HoldingController, bool& bIsHeld)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_IsHeld instead.");
	}
	bool IVRGripInterface::IsInteractible()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_IsInteractible instead.");
		VRGripInterface_eventIsInteractible_Parms Parms;
		return Parms.ReturnValue;
	}
	void IVRGripInterface::OnChildGrip(UGripMotionControllerComponent* GrippingController, FBPActorGripInformation const& GripInformation)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_OnChildGrip instead.");
	}
	void IVRGripInterface::OnChildGripRelease(UGripMotionControllerComponent* ReleasingController, FBPActorGripInformation const& GripInformation)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_OnChildGripRelease instead.");
	}
	void IVRGripInterface::OnEndSecondaryUsed()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_OnEndSecondaryUsed instead.");
	}
	void IVRGripInterface::OnEndUsed()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_OnEndUsed instead.");
	}
	void IVRGripInterface::OnGrip(UGripMotionControllerComponent* GrippingController, FBPActorGripInformation const& GripInformation)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_OnGrip instead.");
	}
	void IVRGripInterface::OnGripRelease(UGripMotionControllerComponent* ReleasingController, FBPActorGripInformation const& GripInformation)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_OnGripRelease instead.");
	}
	void IVRGripInterface::OnSecondaryGrip(USceneComponent* SecondaryGripComponent, FBPActorGripInformation const& GripInformation)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_OnSecondaryGrip instead.");
	}
	void IVRGripInterface::OnSecondaryGripRelease(USceneComponent* ReleasingSecondaryGripComponent, FBPActorGripInformation const& GripInformation)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_OnSecondaryGripRelease instead.");
	}
	void IVRGripInterface::OnSecondaryUsed()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_OnSecondaryUsed instead.");
	}
	void IVRGripInterface::OnUsed()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_OnUsed instead.");
	}
	ESecondaryGripType IVRGripInterface::SecondaryGripType()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_SecondaryGripType instead.");
		VRGripInterface_eventSecondaryGripType_Parms Parms;
		return Parms.ReturnValue;
	}
	void IVRGripInterface::SetHeld(UGripMotionControllerComponent* HoldingController, bool bIsHeld)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_SetHeld instead.");
	}
	bool IVRGripInterface::SimulateOnDrop()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_SimulateOnDrop instead.");
		VRGripInterface_eventSimulateOnDrop_Parms Parms;
		return Parms.ReturnValue;
	}
	EGripCollisionType IVRGripInterface::SlotGripType()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_SlotGripType instead.");
		VRGripInterface_eventSlotGripType_Parms Parms;
		return Parms.ReturnValue;
	}
	EGripInterfaceTeleportBehavior IVRGripInterface::TeleportBehavior()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_TeleportBehavior instead.");
		VRGripInterface_eventTeleportBehavior_Parms Parms;
		return Parms.ReturnValue;
	}
	void IVRGripInterface::TickGrip(UGripMotionControllerComponent* GrippingController, FBPActorGripInformation const& GripInformation, float DeltaTime)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_TickGrip instead.");
	}
	void UVRGripInterface::StaticRegisterNativesUVRGripInterface()
	{
		UClass* Class = UVRGripInterface::StaticClass();
		static const TNameNativePtrPair<ANSICHAR> AnsiFuncs[] = {
			{ "AdvancedPhysicsSettings", (Native)&IVRGripInterface::execAdvancedPhysicsSettings },
			{ "ClosestPrimarySlotInRange", (Native)&IVRGripInterface::execClosestPrimarySlotInRange },
			{ "ClosestSecondarySlotInRange", (Native)&IVRGripInterface::execClosestSecondarySlotInRange },
			{ "DenyGripping", (Native)&IVRGripInterface::execDenyGripping },
			{ "FreeGripType", (Native)&IVRGripInterface::execFreeGripType },
			{ "GetInteractionSettings", (Native)&IVRGripInterface::execGetInteractionSettings },
			{ "GripBreakDistance", (Native)&IVRGripInterface::execGripBreakDistance },
			{ "GripDamping", (Native)&IVRGripInterface::execGripDamping },
			{ "GripLateUpdateSetting", (Native)&IVRGripInterface::execGripLateUpdateSetting },
			{ "GripMovementReplicationType", (Native)&IVRGripInterface::execGripMovementReplicationType },
			{ "GripStiffness", (Native)&IVRGripInterface::execGripStiffness },
			{ "IsHeld", (Native)&IVRGripInterface::execIsHeld },
			{ "IsInteractible", (Native)&IVRGripInterface::execIsInteractible },
			{ "OnChildGrip", (Native)&IVRGripInterface::execOnChildGrip },
			{ "OnChildGripRelease", (Native)&IVRGripInterface::execOnChildGripRelease },
			{ "OnEndSecondaryUsed", (Native)&IVRGripInterface::execOnEndSecondaryUsed },
			{ "OnEndUsed", (Native)&IVRGripInterface::execOnEndUsed },
			{ "OnGrip", (Native)&IVRGripInterface::execOnGrip },
			{ "OnGripRelease", (Native)&IVRGripInterface::execOnGripRelease },
			{ "OnSecondaryGrip", (Native)&IVRGripInterface::execOnSecondaryGrip },
			{ "OnSecondaryGripRelease", (Native)&IVRGripInterface::execOnSecondaryGripRelease },
			{ "OnSecondaryUsed", (Native)&IVRGripInterface::execOnSecondaryUsed },
			{ "OnUsed", (Native)&IVRGripInterface::execOnUsed },
			{ "SecondaryGripType", (Native)&IVRGripInterface::execSecondaryGripType },
			{ "SetHeld", (Native)&IVRGripInterface::execSetHeld },
			{ "SimulateOnDrop", (Native)&IVRGripInterface::execSimulateOnDrop },
			{ "SlotGripType", (Native)&IVRGripInterface::execSlotGripType },
			{ "TeleportBehavior", (Native)&IVRGripInterface::execTeleportBehavior },
			{ "TickGrip", (Native)&IVRGripInterface::execTickGrip },
		};
		FNativeFunctionRegistrar::RegisterFunctions(Class, AnsiFuncs, ARRAY_COUNT(AnsiFuncs));
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_AdvancedPhysicsSettings()
	{
		UObject* Outer = Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AdvancedPhysicsSettings"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), nullptr, (EFunctionFlags)0x0C020C00, 65535, sizeof(VRGripInterface_eventAdvancedPhysicsSettings_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, VRGripInterface_eventAdvancedPhysicsSettings_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FBPAdvGripPhysicsSettings());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get the advanced physics settings for this grip"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_ClosestPrimarySlotInRange()
	{
		UObject* Outer = Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ClosestPrimarySlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), nullptr, (EFunctionFlags)0x0CC20C00, 65535, sizeof(VRGripInterface_eventClosestPrimarySlotInRange_Parms));
			UProperty* NewProp_OverridePrefix = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OverridePrefix"), RF_Public|RF_Transient|RF_MarkAsNative) UNameProperty(CPP_PROPERTY_BASE(OverridePrefix, VRGripInterface_eventClosestPrimarySlotInRange_Parms), 0x0010000000000080);
			UProperty* NewProp_CallingController = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CallingController"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(CallingController, VRGripInterface_eventClosestPrimarySlotInRange_Parms), 0x0010000000080080, Z_Construct_UClass_UGripMotionControllerComponent_NoRegister());
			UProperty* NewProp_SlotWorldTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SlotWorldTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(SlotWorldTransform, VRGripInterface_eventClosestPrimarySlotInRange_Parms), 0x0010000000000180, Z_Construct_UScriptStruct_FTransform());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHadSlotInRange, VRGripInterface_eventClosestPrimarySlotInRange_Parms);
			UProperty* NewProp_bHadSlotInRange = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bHadSlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHadSlotInRange, VRGripInterface_eventClosestPrimarySlotInRange_Parms), 0x0010000000000180, CPP_BOOL_PROPERTY_BITMASK(bHadSlotInRange, VRGripInterface_eventClosestPrimarySlotInRange_Parms), sizeof(bool), true);
			UProperty* NewProp_WorldLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldLocation, VRGripInterface_eventClosestPrimarySlotInRange_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_OverridePrefix"), TEXT("None"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get closest primary slot in range"));
			MetaData->SetValue(NewProp_CallingController, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_ClosestSecondarySlotInRange()
	{
		UObject* Outer = Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ClosestSecondarySlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), nullptr, (EFunctionFlags)0x0CC20C00, 65535, sizeof(VRGripInterface_eventClosestSecondarySlotInRange_Parms));
			UProperty* NewProp_OverridePrefix = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OverridePrefix"), RF_Public|RF_Transient|RF_MarkAsNative) UNameProperty(CPP_PROPERTY_BASE(OverridePrefix, VRGripInterface_eventClosestSecondarySlotInRange_Parms), 0x0010000000000080);
			UProperty* NewProp_CallingController = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("CallingController"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(CallingController, VRGripInterface_eventClosestSecondarySlotInRange_Parms), 0x0010000000080080, Z_Construct_UClass_UGripMotionControllerComponent_NoRegister());
			UProperty* NewProp_SlotWorldTransform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SlotWorldTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(SlotWorldTransform, VRGripInterface_eventClosestSecondarySlotInRange_Parms), 0x0010000000000180, Z_Construct_UScriptStruct_FTransform());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bHadSlotInRange, VRGripInterface_eventClosestSecondarySlotInRange_Parms);
			UProperty* NewProp_bHadSlotInRange = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bHadSlotInRange"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bHadSlotInRange, VRGripInterface_eventClosestSecondarySlotInRange_Parms), 0x0010000000000180, CPP_BOOL_PROPERTY_BITMASK(bHadSlotInRange, VRGripInterface_eventClosestSecondarySlotInRange_Parms), sizeof(bool), true);
			UProperty* NewProp_WorldLocation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("WorldLocation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WorldLocation, VRGripInterface_eventClosestSecondarySlotInRange_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_OverridePrefix"), TEXT("None"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get closest secondary slot in range"));
			MetaData->SetValue(NewProp_CallingController, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_DenyGripping()
	{
		UObject* Outer = Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("DenyGripping"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), nullptr, (EFunctionFlags)0x0C020C00, 65535, sizeof(VRGripInterface_eventDenyGripping_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, VRGripInterface_eventDenyGripping_Parms);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, VRGripInterface_eventDenyGripping_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, VRGripInterface_eventDenyGripping_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set up as deny instead of allow so that default allows for gripping"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_FreeGripType()
	{
		UObject* Outer = Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FreeGripType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), nullptr, (EFunctionFlags)0x0C020C00, 65535, sizeof(VRGripInterface_eventFreeGripType_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UEnumProperty(CPP_PROPERTY_BASE(ReturnValue, VRGripInterface_eventFreeGripType_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripCollisionType());
			UProperty* NewProp_ReturnValue_Underlying = new(EC_InternalUseOnlyConstructor, NewProp_ReturnValue, TEXT("UnderlyingType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Grip type to use when not gripping a slot"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_GetInteractionSettings()
	{
		UObject* Outer = Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetInteractionSettings"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), nullptr, (EFunctionFlags)0x0C020C00, 65535, sizeof(VRGripInterface_eventGetInteractionSettings_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, VRGripInterface_eventGetInteractionSettings_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FBPInteractionSettings());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Get interactable settings"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_GripBreakDistance()
	{
		UObject* Outer = Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripBreakDistance"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), nullptr, (EFunctionFlags)0x0C020C00, 65535, sizeof(VRGripInterface_eventGripBreakDistance_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, VRGripInterface_eventGripBreakDistance_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("What distance to break a grip at (only relevent with physics enabled grips"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_GripDamping()
	{
		UObject* Outer = Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripDamping"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), nullptr, (EFunctionFlags)0x0C020C00, 65535, sizeof(VRGripInterface_eventGripDamping_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, VRGripInterface_eventGripDamping_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("What grip damping to use if using a physics constraint"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_GripLateUpdateSetting()
	{
		UObject* Outer = Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripLateUpdateSetting"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), nullptr, (EFunctionFlags)0x0C020C00, 65535, sizeof(VRGripInterface_eventGripLateUpdateSetting_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UEnumProperty(CPP_PROPERTY_BASE(ReturnValue, VRGripInterface_eventGripLateUpdateSetting_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripLateUpdateSettings());
			UProperty* NewProp_ReturnValue_Underlying = new(EC_InternalUseOnlyConstructor, NewProp_ReturnValue, TEXT("UnderlyingType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Define the late update setting"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_GripMovementReplicationType()
	{
		UObject* Outer = Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripMovementReplicationType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), nullptr, (EFunctionFlags)0x0C020C00, 65535, sizeof(VRGripInterface_eventGripMovementReplicationType_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UEnumProperty(CPP_PROPERTY_BASE(ReturnValue, VRGripInterface_eventGripMovementReplicationType_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripMovementReplicationSettings());
			UProperty* NewProp_ReturnValue_Underlying = new(EC_InternalUseOnlyConstructor, NewProp_ReturnValue, TEXT("UnderlyingType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Define which movement repliation setting to use"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_GripStiffness()
	{
		UObject* Outer = Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GripStiffness"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), nullptr, (EFunctionFlags)0x0C020C00, 65535, sizeof(VRGripInterface_eventGripStiffness_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, VRGripInterface_eventGripStiffness_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("What grip stiffness to use if using a physics constraint"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_IsHeld()
	{
		UObject* Outer = Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsHeld"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), nullptr, (EFunctionFlags)0x0C420C00, 65535, sizeof(VRGripInterface_eventIsHeld_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIsHeld, VRGripInterface_eventIsHeld_Parms);
			UProperty* NewProp_bIsHeld = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bIsHeld"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIsHeld, VRGripInterface_eventIsHeld_Parms), 0x0010000000000180, CPP_BOOL_PROPERTY_BITMASK(bIsHeld, VRGripInterface_eventIsHeld_Parms), sizeof(bool), true);
			UProperty* NewProp_HoldingController = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HoldingController"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(HoldingController, VRGripInterface_eventIsHeld_Parms), 0x0010000000080180, Z_Construct_UClass_UGripMotionControllerComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns if the object is held and if so, which pawn is holding it"));
			MetaData->SetValue(NewProp_HoldingController, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_IsInteractible()
	{
		UObject* Outer = Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsInteractible"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), nullptr, (EFunctionFlags)0x0C020C00, 65535, sizeof(VRGripInterface_eventIsInteractible_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, VRGripInterface_eventIsInteractible_Parms);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, VRGripInterface_eventIsInteractible_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, VRGripInterface_eventIsInteractible_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Check if the object is an interactable"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_OnChildGrip()
	{
		UObject* Outer = Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnChildGrip"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), nullptr, (EFunctionFlags)0x08420C00, 65535, sizeof(VRGripInterface_eventOnChildGrip_Parms));
			UProperty* NewProp_GripInformation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GripInformation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(GripInformation, VRGripInterface_eventOnChildGrip_Parms), 0x0010008008000182, Z_Construct_UScriptStruct_FBPActorGripInformation());
			UProperty* NewProp_GrippingController = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GrippingController"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(GrippingController, VRGripInterface_eventOnChildGrip_Parms), 0x0010000000080080, Z_Construct_UClass_UGripMotionControllerComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered on the interfaced object when child component is gripped"));
			MetaData->SetValue(NewProp_GripInformation, TEXT("NativeConst"), TEXT(""));
			MetaData->SetValue(NewProp_GrippingController, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_OnChildGripRelease()
	{
		UObject* Outer = Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnChildGripRelease"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), nullptr, (EFunctionFlags)0x08420C00, 65535, sizeof(VRGripInterface_eventOnChildGripRelease_Parms));
			UProperty* NewProp_GripInformation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GripInformation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(GripInformation, VRGripInterface_eventOnChildGripRelease_Parms), 0x0010008008000182, Z_Construct_UScriptStruct_FBPActorGripInformation());
			UProperty* NewProp_ReleasingController = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReleasingController"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReleasingController, VRGripInterface_eventOnChildGripRelease_Parms), 0x0010000000080080, Z_Construct_UClass_UGripMotionControllerComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered on the interfaced object when child component is released"));
			MetaData->SetValue(NewProp_GripInformation, TEXT("NativeConst"), TEXT(""));
			MetaData->SetValue(NewProp_ReleasingController, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_OnEndSecondaryUsed()
	{
		UObject* Outer = Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnEndSecondaryUsed"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), nullptr, (EFunctionFlags)0x0C020C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Call to stop using an object"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_OnEndUsed()
	{
		UObject* Outer = Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnEndUsed"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), nullptr, (EFunctionFlags)0x0C020C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Call to stop using an object"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_OnGrip()
	{
		UObject* Outer = Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnGrip"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), nullptr, (EFunctionFlags)0x08420C00, 65535, sizeof(VRGripInterface_eventOnGrip_Parms));
			UProperty* NewProp_GripInformation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GripInformation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(GripInformation, VRGripInterface_eventOnGrip_Parms), 0x0010008008000182, Z_Construct_UScriptStruct_FBPActorGripInformation());
			UProperty* NewProp_GrippingController = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GrippingController"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(GrippingController, VRGripInterface_eventOnGrip_Parms), 0x0010000000080080, Z_Construct_UClass_UGripMotionControllerComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered on the interfaced object when gripped"));
			MetaData->SetValue(NewProp_GripInformation, TEXT("NativeConst"), TEXT(""));
			MetaData->SetValue(NewProp_GrippingController, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_OnGripRelease()
	{
		UObject* Outer = Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnGripRelease"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), nullptr, (EFunctionFlags)0x08420C00, 65535, sizeof(VRGripInterface_eventOnGripRelease_Parms));
			UProperty* NewProp_GripInformation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GripInformation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(GripInformation, VRGripInterface_eventOnGripRelease_Parms), 0x0010008008000182, Z_Construct_UScriptStruct_FBPActorGripInformation());
			UProperty* NewProp_ReleasingController = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReleasingController"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReleasingController, VRGripInterface_eventOnGripRelease_Parms), 0x0010000000080080, Z_Construct_UClass_UGripMotionControllerComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered on the interfaced object when grip is released"));
			MetaData->SetValue(NewProp_GripInformation, TEXT("NativeConst"), TEXT(""));
			MetaData->SetValue(NewProp_ReleasingController, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_OnSecondaryGrip()
	{
		UObject* Outer = Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnSecondaryGrip"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), nullptr, (EFunctionFlags)0x08420C00, 65535, sizeof(VRGripInterface_eventOnSecondaryGrip_Parms));
			UProperty* NewProp_GripInformation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GripInformation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(GripInformation, VRGripInterface_eventOnSecondaryGrip_Parms), 0x0010008008000182, Z_Construct_UScriptStruct_FBPActorGripInformation());
			UProperty* NewProp_SecondaryGripComponent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SecondaryGripComponent"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(SecondaryGripComponent, VRGripInterface_eventOnSecondaryGrip_Parms), 0x0010000000080080, Z_Construct_UClass_USceneComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered on the interfaced object when secondary gripped"));
			MetaData->SetValue(NewProp_GripInformation, TEXT("NativeConst"), TEXT(""));
			MetaData->SetValue(NewProp_SecondaryGripComponent, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_OnSecondaryGripRelease()
	{
		UObject* Outer = Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnSecondaryGripRelease"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), nullptr, (EFunctionFlags)0x08420C00, 65535, sizeof(VRGripInterface_eventOnSecondaryGripRelease_Parms));
			UProperty* NewProp_GripInformation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GripInformation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(GripInformation, VRGripInterface_eventOnSecondaryGripRelease_Parms), 0x0010008008000182, Z_Construct_UScriptStruct_FBPActorGripInformation());
			UProperty* NewProp_ReleasingSecondaryGripComponent = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReleasingSecondaryGripComponent"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReleasingSecondaryGripComponent, VRGripInterface_eventOnSecondaryGripRelease_Parms), 0x0010000000080080, Z_Construct_UClass_USceneComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered on the interfaced object when secondary grip is released"));
			MetaData->SetValue(NewProp_GripInformation, TEXT("NativeConst"), TEXT(""));
			MetaData->SetValue(NewProp_ReleasingSecondaryGripComponent, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_OnSecondaryUsed()
	{
		UObject* Outer = Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnSecondaryUsed"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), nullptr, (EFunctionFlags)0x0C020C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Call to use an object"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_OnUsed()
	{
		UObject* Outer = Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnUsed"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), nullptr, (EFunctionFlags)0x0C020C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Call to use an object"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_SecondaryGripType()
	{
		UObject* Outer = Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SecondaryGripType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), nullptr, (EFunctionFlags)0x0C020C00, 65535, sizeof(VRGripInterface_eventSecondaryGripType_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UEnumProperty(CPP_PROPERTY_BASE(ReturnValue, VRGripInterface_eventSecondaryGripType_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_ESecondaryGripType());
			UProperty* NewProp_ReturnValue_Underlying = new(EC_InternalUseOnlyConstructor, NewProp_ReturnValue, TEXT("UnderlyingType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Double Grip Type"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_SetHeld()
	{
		UObject* Outer = Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetHeld"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), nullptr, (EFunctionFlags)0x0C020C00, 65535, sizeof(VRGripInterface_eventSetHeld_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIsHeld, VRGripInterface_eventSetHeld_Parms);
			UProperty* NewProp_bIsHeld = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bIsHeld"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIsHeld, VRGripInterface_eventSetHeld_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bIsHeld, VRGripInterface_eventSetHeld_Parms), sizeof(bool), true);
			UProperty* NewProp_HoldingController = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HoldingController"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(HoldingController, VRGripInterface_eventSetHeld_Parms), 0x0010000000080080, Z_Construct_UClass_UGripMotionControllerComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Sets is held, used by the plugin"));
			MetaData->SetValue(NewProp_HoldingController, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_SimulateOnDrop()
	{
		UObject* Outer = Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SimulateOnDrop"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), nullptr, (EFunctionFlags)0x0C020C00, 65535, sizeof(VRGripInterface_eventSimulateOnDrop_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, VRGripInterface_eventSimulateOnDrop_Parms);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, VRGripInterface_eventSimulateOnDrop_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, VRGripInterface_eventSimulateOnDrop_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Should this object simulate on drop"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_SlotGripType()
	{
		UObject* Outer = Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SlotGripType"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), nullptr, (EFunctionFlags)0x0C020C00, 65535, sizeof(VRGripInterface_eventSlotGripType_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UEnumProperty(CPP_PROPERTY_BASE(ReturnValue, VRGripInterface_eventSlotGripType_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripCollisionType());
			UProperty* NewProp_ReturnValue_Underlying = new(EC_InternalUseOnlyConstructor, NewProp_ReturnValue, TEXT("UnderlyingType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Grip type to use when gripping a slot"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_TeleportBehavior()
	{
		UObject* Outer = Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TeleportBehavior"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), nullptr, (EFunctionFlags)0x0C020C00, 65535, sizeof(VRGripInterface_eventTeleportBehavior_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UEnumProperty(CPP_PROPERTY_BASE(ReturnValue, VRGripInterface_eventTeleportBehavior_Parms), 0x0010000000000580, Z_Construct_UEnum_VRExpansionPlugin_EGripInterfaceTeleportBehavior());
			UProperty* NewProp_ReturnValue_Underlying = new(EC_InternalUseOnlyConstructor, NewProp_ReturnValue, TEXT("UnderlyingType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("How an interfaced object behaves when teleporting"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UVRGripInterface_TickGrip()
	{
		UObject* Outer = Z_Construct_UClass_UVRGripInterface();
		static UFunction* ReturnFunction = nullptr;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TickGrip"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), nullptr, (EFunctionFlags)0x08420C00, 65535, sizeof(VRGripInterface_eventTickGrip_Parms));
			UProperty* NewProp_DeltaTime = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("DeltaTime"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(DeltaTime, VRGripInterface_eventTickGrip_Parms), 0x0010000000000080);
			UProperty* NewProp_GripInformation = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GripInformation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(GripInformation, VRGripInterface_eventTickGrip_Parms), 0x0010008008000182, Z_Construct_UScriptStruct_FBPActorGripInformation());
			UProperty* NewProp_GrippingController = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GrippingController"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(GrippingController, VRGripInterface_eventTickGrip_Parms), 0x0010000000080080, Z_Construct_UClass_UGripMotionControllerComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("VRGripInterface"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered each tick on the interfaced object when gripped, can be used for custom movement or grip based logic"));
			MetaData->SetValue(NewProp_GripInformation, TEXT("NativeConst"), TEXT(""));
			MetaData->SetValue(NewProp_GrippingController, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UVRGripInterface_NoRegister()
	{
		return UVRGripInterface::StaticClass();
	}
	UClass* Z_Construct_UClass_UVRGripInterface()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UInterface();
			Z_Construct_UPackage__Script_VRExpansionPlugin();
			OuterClass = UVRGripInterface::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= (EClassFlags)0x20104081u;

				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_AdvancedPhysicsSettings());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_ClosestPrimarySlotInRange());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_ClosestSecondarySlotInRange());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_DenyGripping());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_FreeGripType());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_GetInteractionSettings());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_GripBreakDistance());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_GripDamping());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_GripLateUpdateSetting());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_GripMovementReplicationType());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_GripStiffness());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_IsHeld());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_IsInteractible());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_OnChildGrip());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_OnChildGripRelease());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_OnEndSecondaryUsed());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_OnEndUsed());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_OnGrip());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_OnGripRelease());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_OnSecondaryGrip());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_OnSecondaryGripRelease());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_OnSecondaryUsed());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_OnUsed());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_SecondaryGripType());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_SetHeld());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_SimulateOnDrop());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_SlotGripType());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_TeleportBehavior());
				OuterClass->LinkChild(Z_Construct_UFunction_UVRGripInterface_TickGrip());

				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_AdvancedPhysicsSettings(), "AdvancedPhysicsSettings"); // 3160872284
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_ClosestPrimarySlotInRange(), "ClosestPrimarySlotInRange"); // 1978595717
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_ClosestSecondarySlotInRange(), "ClosestSecondarySlotInRange"); // 732073945
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_DenyGripping(), "DenyGripping"); // 3659384107
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_FreeGripType(), "FreeGripType"); // 1408823068
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_GetInteractionSettings(), "GetInteractionSettings"); // 2461455184
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_GripBreakDistance(), "GripBreakDistance"); // 1770181167
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_GripDamping(), "GripDamping"); // 938557792
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_GripLateUpdateSetting(), "GripLateUpdateSetting"); // 970383677
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_GripMovementReplicationType(), "GripMovementReplicationType"); // 2989167149
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_GripStiffness(), "GripStiffness"); // 4282921758
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_IsHeld(), "IsHeld"); // 2264592603
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_IsInteractible(), "IsInteractible"); // 1643971886
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_OnChildGrip(), "OnChildGrip"); // 4142347081
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_OnChildGripRelease(), "OnChildGripRelease"); // 3248905460
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_OnEndSecondaryUsed(), "OnEndSecondaryUsed"); // 3432839378
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_OnEndUsed(), "OnEndUsed"); // 1404778255
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_OnGrip(), "OnGrip"); // 2947799425
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_OnGripRelease(), "OnGripRelease"); // 3209502920
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_OnSecondaryGrip(), "OnSecondaryGrip"); // 958918108
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_OnSecondaryGripRelease(), "OnSecondaryGripRelease"); // 1546098878
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_OnSecondaryUsed(), "OnSecondaryUsed"); // 497623074
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_OnUsed(), "OnUsed"); // 1295896575
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_SecondaryGripType(), "SecondaryGripType"); // 157563974
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_SetHeld(), "SetHeld"); // 958688789
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_SimulateOnDrop(), "SimulateOnDrop"); // 516065297
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_SlotGripType(), "SlotGripType"); // 1120266948
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_TeleportBehavior(), "TeleportBehavior"); // 2358216455
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UVRGripInterface_TickGrip(), "TickGrip"); // 3316309967
				static TCppClassTypeInfo<TCppClassTypeTraits<IVRGripInterface> > StaticCppClassTypeInfo;
				OuterClass->SetCppTypeInfo(&StaticCppClassTypeInfo);
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/VRGripInterface.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	IMPLEMENT_CLASS(UVRGripInterface, 3792660231);
	static FCompiledInDefer Z_CompiledInDefer_UClass_UVRGripInterface(Z_Construct_UClass_UVRGripInterface, &UVRGripInterface::StaticClass, TEXT("/Script/VRExpansionPlugin"), TEXT("UVRGripInterface"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UVRGripInterface);
	static FName NAME_UVRGripInterface_AdvancedPhysicsSettings = FName(TEXT("AdvancedPhysicsSettings"));
	FBPAdvGripPhysicsSettings IVRGripInterface::Execute_AdvancedPhysicsSettings(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventAdvancedPhysicsSettings_Parms Parms;
		UFunction* const Func = O->FindFunction(NAME_UVRGripInterface_AdvancedPhysicsSettings);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			Parms.ReturnValue = I->AdvancedPhysicsSettings_Implementation();
		}
		return Parms.ReturnValue;
	}
	static FName NAME_UVRGripInterface_ClosestPrimarySlotInRange = FName(TEXT("ClosestPrimarySlotInRange"));
	void IVRGripInterface::Execute_ClosestPrimarySlotInRange(UObject* O, FVector WorldLocation, bool& bHadSlotInRange, FTransform& SlotWorldTransform, UGripMotionControllerComponent* CallingController, FName OverridePrefix)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventClosestPrimarySlotInRange_Parms Parms;
		UFunction* const Func = O->FindFunction(NAME_UVRGripInterface_ClosestPrimarySlotInRange);
		if (Func)
		{
			Parms.WorldLocation=WorldLocation;
			Parms.bHadSlotInRange=bHadSlotInRange;
			Parms.SlotWorldTransform=SlotWorldTransform;
			Parms.CallingController=CallingController;
			Parms.OverridePrefix=OverridePrefix;
			O->ProcessEvent(Func, &Parms);
			bHadSlotInRange=Parms.bHadSlotInRange;
			SlotWorldTransform=Parms.SlotWorldTransform;
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			I->ClosestPrimarySlotInRange_Implementation(WorldLocation,bHadSlotInRange,SlotWorldTransform,CallingController,OverridePrefix);
		}
	}
	static FName NAME_UVRGripInterface_ClosestSecondarySlotInRange = FName(TEXT("ClosestSecondarySlotInRange"));
	void IVRGripInterface::Execute_ClosestSecondarySlotInRange(UObject* O, FVector WorldLocation, bool& bHadSlotInRange, FTransform& SlotWorldTransform, UGripMotionControllerComponent* CallingController, FName OverridePrefix)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventClosestSecondarySlotInRange_Parms Parms;
		UFunction* const Func = O->FindFunction(NAME_UVRGripInterface_ClosestSecondarySlotInRange);
		if (Func)
		{
			Parms.WorldLocation=WorldLocation;
			Parms.bHadSlotInRange=bHadSlotInRange;
			Parms.SlotWorldTransform=SlotWorldTransform;
			Parms.CallingController=CallingController;
			Parms.OverridePrefix=OverridePrefix;
			O->ProcessEvent(Func, &Parms);
			bHadSlotInRange=Parms.bHadSlotInRange;
			SlotWorldTransform=Parms.SlotWorldTransform;
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			I->ClosestSecondarySlotInRange_Implementation(WorldLocation,bHadSlotInRange,SlotWorldTransform,CallingController,OverridePrefix);
		}
	}
	static FName NAME_UVRGripInterface_DenyGripping = FName(TEXT("DenyGripping"));
	bool IVRGripInterface::Execute_DenyGripping(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventDenyGripping_Parms Parms;
		UFunction* const Func = O->FindFunction(NAME_UVRGripInterface_DenyGripping);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			Parms.ReturnValue = I->DenyGripping_Implementation();
		}
		return Parms.ReturnValue;
	}
	static FName NAME_UVRGripInterface_FreeGripType = FName(TEXT("FreeGripType"));
	EGripCollisionType IVRGripInterface::Execute_FreeGripType(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventFreeGripType_Parms Parms;
		UFunction* const Func = O->FindFunction(NAME_UVRGripInterface_FreeGripType);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			Parms.ReturnValue = I->FreeGripType_Implementation();
		}
		return Parms.ReturnValue;
	}
	static FName NAME_UVRGripInterface_GetInteractionSettings = FName(TEXT("GetInteractionSettings"));
	FBPInteractionSettings IVRGripInterface::Execute_GetInteractionSettings(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventGetInteractionSettings_Parms Parms;
		UFunction* const Func = O->FindFunction(NAME_UVRGripInterface_GetInteractionSettings);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			Parms.ReturnValue = I->GetInteractionSettings_Implementation();
		}
		return Parms.ReturnValue;
	}
	static FName NAME_UVRGripInterface_GripBreakDistance = FName(TEXT("GripBreakDistance"));
	float IVRGripInterface::Execute_GripBreakDistance(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventGripBreakDistance_Parms Parms;
		UFunction* const Func = O->FindFunction(NAME_UVRGripInterface_GripBreakDistance);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			Parms.ReturnValue = I->GripBreakDistance_Implementation();
		}
		return Parms.ReturnValue;
	}
	static FName NAME_UVRGripInterface_GripDamping = FName(TEXT("GripDamping"));
	float IVRGripInterface::Execute_GripDamping(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventGripDamping_Parms Parms;
		UFunction* const Func = O->FindFunction(NAME_UVRGripInterface_GripDamping);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			Parms.ReturnValue = I->GripDamping_Implementation();
		}
		return Parms.ReturnValue;
	}
	static FName NAME_UVRGripInterface_GripLateUpdateSetting = FName(TEXT("GripLateUpdateSetting"));
	EGripLateUpdateSettings IVRGripInterface::Execute_GripLateUpdateSetting(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventGripLateUpdateSetting_Parms Parms;
		UFunction* const Func = O->FindFunction(NAME_UVRGripInterface_GripLateUpdateSetting);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			Parms.ReturnValue = I->GripLateUpdateSetting_Implementation();
		}
		return Parms.ReturnValue;
	}
	static FName NAME_UVRGripInterface_GripMovementReplicationType = FName(TEXT("GripMovementReplicationType"));
	EGripMovementReplicationSettings IVRGripInterface::Execute_GripMovementReplicationType(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventGripMovementReplicationType_Parms Parms;
		UFunction* const Func = O->FindFunction(NAME_UVRGripInterface_GripMovementReplicationType);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			Parms.ReturnValue = I->GripMovementReplicationType_Implementation();
		}
		return Parms.ReturnValue;
	}
	static FName NAME_UVRGripInterface_GripStiffness = FName(TEXT("GripStiffness"));
	float IVRGripInterface::Execute_GripStiffness(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventGripStiffness_Parms Parms;
		UFunction* const Func = O->FindFunction(NAME_UVRGripInterface_GripStiffness);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			Parms.ReturnValue = I->GripStiffness_Implementation();
		}
		return Parms.ReturnValue;
	}
	static FName NAME_UVRGripInterface_IsHeld = FName(TEXT("IsHeld"));
	void IVRGripInterface::Execute_IsHeld(UObject* O, UGripMotionControllerComponent*& HoldingController, bool& bIsHeld)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventIsHeld_Parms Parms;
		UFunction* const Func = O->FindFunction(NAME_UVRGripInterface_IsHeld);
		if (Func)
		{
			Parms.HoldingController=HoldingController;
			Parms.bIsHeld=bIsHeld;
			O->ProcessEvent(Func, &Parms);
			HoldingController=Parms.HoldingController;
			bIsHeld=Parms.bIsHeld;
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			I->IsHeld_Implementation(HoldingController,bIsHeld);
		}
	}
	static FName NAME_UVRGripInterface_IsInteractible = FName(TEXT("IsInteractible"));
	bool IVRGripInterface::Execute_IsInteractible(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventIsInteractible_Parms Parms;
		UFunction* const Func = O->FindFunction(NAME_UVRGripInterface_IsInteractible);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			Parms.ReturnValue = I->IsInteractible_Implementation();
		}
		return Parms.ReturnValue;
	}
	static FName NAME_UVRGripInterface_OnChildGrip = FName(TEXT("OnChildGrip"));
	void IVRGripInterface::Execute_OnChildGrip(UObject* O, UGripMotionControllerComponent* GrippingController, FBPActorGripInformation const& GripInformation)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventOnChildGrip_Parms Parms;
		UFunction* const Func = O->FindFunction(NAME_UVRGripInterface_OnChildGrip);
		if (Func)
		{
			Parms.GrippingController=GrippingController;
			Parms.GripInformation=GripInformation;
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			I->OnChildGrip_Implementation(GrippingController,GripInformation);
		}
	}
	static FName NAME_UVRGripInterface_OnChildGripRelease = FName(TEXT("OnChildGripRelease"));
	void IVRGripInterface::Execute_OnChildGripRelease(UObject* O, UGripMotionControllerComponent* ReleasingController, FBPActorGripInformation const& GripInformation)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventOnChildGripRelease_Parms Parms;
		UFunction* const Func = O->FindFunction(NAME_UVRGripInterface_OnChildGripRelease);
		if (Func)
		{
			Parms.ReleasingController=ReleasingController;
			Parms.GripInformation=GripInformation;
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			I->OnChildGripRelease_Implementation(ReleasingController,GripInformation);
		}
	}
	static FName NAME_UVRGripInterface_OnEndSecondaryUsed = FName(TEXT("OnEndSecondaryUsed"));
	void IVRGripInterface::Execute_OnEndSecondaryUsed(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		UFunction* const Func = O->FindFunction(NAME_UVRGripInterface_OnEndSecondaryUsed);
		if (Func)
		{
			O->ProcessEvent(Func, NULL);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			I->OnEndSecondaryUsed_Implementation();
		}
	}
	static FName NAME_UVRGripInterface_OnEndUsed = FName(TEXT("OnEndUsed"));
	void IVRGripInterface::Execute_OnEndUsed(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		UFunction* const Func = O->FindFunction(NAME_UVRGripInterface_OnEndUsed);
		if (Func)
		{
			O->ProcessEvent(Func, NULL);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			I->OnEndUsed_Implementation();
		}
	}
	static FName NAME_UVRGripInterface_OnGrip = FName(TEXT("OnGrip"));
	void IVRGripInterface::Execute_OnGrip(UObject* O, UGripMotionControllerComponent* GrippingController, FBPActorGripInformation const& GripInformation)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventOnGrip_Parms Parms;
		UFunction* const Func = O->FindFunction(NAME_UVRGripInterface_OnGrip);
		if (Func)
		{
			Parms.GrippingController=GrippingController;
			Parms.GripInformation=GripInformation;
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			I->OnGrip_Implementation(GrippingController,GripInformation);
		}
	}
	static FName NAME_UVRGripInterface_OnGripRelease = FName(TEXT("OnGripRelease"));
	void IVRGripInterface::Execute_OnGripRelease(UObject* O, UGripMotionControllerComponent* ReleasingController, FBPActorGripInformation const& GripInformation)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventOnGripRelease_Parms Parms;
		UFunction* const Func = O->FindFunction(NAME_UVRGripInterface_OnGripRelease);
		if (Func)
		{
			Parms.ReleasingController=ReleasingController;
			Parms.GripInformation=GripInformation;
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			I->OnGripRelease_Implementation(ReleasingController,GripInformation);
		}
	}
	static FName NAME_UVRGripInterface_OnSecondaryGrip = FName(TEXT("OnSecondaryGrip"));
	void IVRGripInterface::Execute_OnSecondaryGrip(UObject* O, USceneComponent* SecondaryGripComponent, FBPActorGripInformation const& GripInformation)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventOnSecondaryGrip_Parms Parms;
		UFunction* const Func = O->FindFunction(NAME_UVRGripInterface_OnSecondaryGrip);
		if (Func)
		{
			Parms.SecondaryGripComponent=SecondaryGripComponent;
			Parms.GripInformation=GripInformation;
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			I->OnSecondaryGrip_Implementation(SecondaryGripComponent,GripInformation);
		}
	}
	static FName NAME_UVRGripInterface_OnSecondaryGripRelease = FName(TEXT("OnSecondaryGripRelease"));
	void IVRGripInterface::Execute_OnSecondaryGripRelease(UObject* O, USceneComponent* ReleasingSecondaryGripComponent, FBPActorGripInformation const& GripInformation)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventOnSecondaryGripRelease_Parms Parms;
		UFunction* const Func = O->FindFunction(NAME_UVRGripInterface_OnSecondaryGripRelease);
		if (Func)
		{
			Parms.ReleasingSecondaryGripComponent=ReleasingSecondaryGripComponent;
			Parms.GripInformation=GripInformation;
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			I->OnSecondaryGripRelease_Implementation(ReleasingSecondaryGripComponent,GripInformation);
		}
	}
	static FName NAME_UVRGripInterface_OnSecondaryUsed = FName(TEXT("OnSecondaryUsed"));
	void IVRGripInterface::Execute_OnSecondaryUsed(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		UFunction* const Func = O->FindFunction(NAME_UVRGripInterface_OnSecondaryUsed);
		if (Func)
		{
			O->ProcessEvent(Func, NULL);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			I->OnSecondaryUsed_Implementation();
		}
	}
	static FName NAME_UVRGripInterface_OnUsed = FName(TEXT("OnUsed"));
	void IVRGripInterface::Execute_OnUsed(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		UFunction* const Func = O->FindFunction(NAME_UVRGripInterface_OnUsed);
		if (Func)
		{
			O->ProcessEvent(Func, NULL);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			I->OnUsed_Implementation();
		}
	}
	static FName NAME_UVRGripInterface_SecondaryGripType = FName(TEXT("SecondaryGripType"));
	ESecondaryGripType IVRGripInterface::Execute_SecondaryGripType(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventSecondaryGripType_Parms Parms;
		UFunction* const Func = O->FindFunction(NAME_UVRGripInterface_SecondaryGripType);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			Parms.ReturnValue = I->SecondaryGripType_Implementation();
		}
		return Parms.ReturnValue;
	}
	static FName NAME_UVRGripInterface_SetHeld = FName(TEXT("SetHeld"));
	void IVRGripInterface::Execute_SetHeld(UObject* O, UGripMotionControllerComponent* HoldingController, bool bIsHeld)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventSetHeld_Parms Parms;
		UFunction* const Func = O->FindFunction(NAME_UVRGripInterface_SetHeld);
		if (Func)
		{
			Parms.HoldingController=HoldingController;
			Parms.bIsHeld=bIsHeld;
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			I->SetHeld_Implementation(HoldingController,bIsHeld);
		}
	}
	static FName NAME_UVRGripInterface_SimulateOnDrop = FName(TEXT("SimulateOnDrop"));
	bool IVRGripInterface::Execute_SimulateOnDrop(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventSimulateOnDrop_Parms Parms;
		UFunction* const Func = O->FindFunction(NAME_UVRGripInterface_SimulateOnDrop);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			Parms.ReturnValue = I->SimulateOnDrop_Implementation();
		}
		return Parms.ReturnValue;
	}
	static FName NAME_UVRGripInterface_SlotGripType = FName(TEXT("SlotGripType"));
	EGripCollisionType IVRGripInterface::Execute_SlotGripType(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventSlotGripType_Parms Parms;
		UFunction* const Func = O->FindFunction(NAME_UVRGripInterface_SlotGripType);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			Parms.ReturnValue = I->SlotGripType_Implementation();
		}
		return Parms.ReturnValue;
	}
	static FName NAME_UVRGripInterface_TeleportBehavior = FName(TEXT("TeleportBehavior"));
	EGripInterfaceTeleportBehavior IVRGripInterface::Execute_TeleportBehavior(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventTeleportBehavior_Parms Parms;
		UFunction* const Func = O->FindFunction(NAME_UVRGripInterface_TeleportBehavior);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			Parms.ReturnValue = I->TeleportBehavior_Implementation();
		}
		return Parms.ReturnValue;
	}
	static FName NAME_UVRGripInterface_TickGrip = FName(TEXT("TickGrip"));
	void IVRGripInterface::Execute_TickGrip(UObject* O, UGripMotionControllerComponent* GrippingController, FBPActorGripInformation const& GripInformation, float DeltaTime)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UVRGripInterface::StaticClass()));
		VRGripInterface_eventTickGrip_Parms Parms;
		UFunction* const Func = O->FindFunction(NAME_UVRGripInterface_TickGrip);
		if (Func)
		{
			Parms.GrippingController=GrippingController;
			Parms.GripInformation=GripInformation;
			Parms.DeltaTime=DeltaTime;
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IVRGripInterface*)(O->GetNativeInterfaceAddress(UVRGripInterface::StaticClass())))
		{
			I->TickGrip_Implementation(GrippingController,GripInformation,DeltaTime);
		}
	}
PRAGMA_ENABLE_DEPRECATION_WARNINGS
#ifdef _MSC_VER
#pragma warning (pop)
#endif
PRAGMA_ENABLE_OPTIMIZATION
